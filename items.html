<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livecoding GLB Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import essential three.js components
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Optional: Add camera controls for debugging
        // const controls = new OrbitControls(camera, renderer.domElement);
        // controls.enableDamping = true;

        // --- 2. Load and Store Your Models ---
        const loader = new GLTFLoader();
        const models = [];
        const textureLoader = new THREE.TextureLoader();

        // Fetch the list of model paths from glbs.txt
        fetch('glbs.txt')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then(text => {
                const paths = text.split('\n').filter(path => path.trim() !== '');
                loadModels(paths);
            })
            .catch(error => {
                console.error('Error fetching glbs.txt:', error);
            });

        // A function to load and position a random subset of models
        function loadModels(paths) {
            const numModelsToLoad = 10;
            const shuffledPaths = paths.sort(() => 0.5 - Math.random());
            const selectedPaths = shuffledPaths.slice(0, numModelsToLoad);

            selectedPaths.forEach((path) => {
                // Generate a random position for each model within a small area
                const x = (Math.random() - 0.5) * 5;
                const y = (Math.random() - 0.5) * 2;
                const z = (Math.random() - 0.5) * 5;
                const position = new THREE.Vector3(x, y, z);

                loader.load(path, (gltf) => {
                    const model = gltf.scene;
                    model.position.copy(position);

                    // Apply a random texture to a new material
                    // const randomTextureIndex = Math.floor(Math.random() * 5) + 1; // Assuming you have texture1.jpg to texture5.jpg
                    const newMaterial = new THREE.MeshStandardMaterial({
                        color: 0xfff
                    //    map: textureLoader.load(`assets/textures/texture${randomTextureIndex}.jpg`)
                    });

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = newMaterial;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    scene.add(model);
                    models.push(model);
                    console.log(`Loaded model: ${path}`);
                }, undefined, (error) => {
                    console.error(`Error loading model from ${path}`, error);
                });
            });
        }

        // --- 3. Animation and Manipulation Loop ---
        let angle = 0; // A variable to track the camera's orbit angle
        const orbitRadius = 7; // Distance of the camera from the center
        const orbitSpeed = 0.01; // How fast the camera moves

        function animate() {
            requestAnimationFrame(animate);

            // Update the camera's position for a quick orbit
            angle += orbitSpeed;
            camera.position.x = Math.sin(angle) * orbitRadius;
            camera.position.y = Math.sin(angle * 0.5) * 1; // Add a slight vertical bobbing
            camera.position.z = Math.cos(angle) * orbitRadius;
            camera.lookAt(0, 0, 0); // Keep the camera focused on the center of the models

            // If you want the models to spin as well
            if (models.length > 0) {
                models.forEach(model => {
                    model.rotation.y += 0.005;
                });
            }

            // Uncomment this line if you re-enable OrbitControls
            // controls.update(); 
            renderer.render(scene, camera);
        }

        animate();

        // --- 4. Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>