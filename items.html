<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livecoding GLB Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import essential three.js components
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Position the camera
        camera.position.set(0, 2, 5);

        // Add lighting
       // const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1.5); // Sky color, ground color, intensity
        // scene.add(hemisphereLight);
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Add camera controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Provides a smooth, inertial feel


// --- 2. Load and Store Your Models ---
const loader = new GLTFLoader();
const models = [];
const newMaterial = new THREE.MeshStandardMaterial({ color: 0xfff });

// Fetch the list of model paths from glbs.txt
fetch('glbs.txt')
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text();
    })
    .then(text => {
        const paths = text.split('\n').filter(path => path.trim() !== '');
        loadModels(paths);
    })
    .catch(error => {
        console.error('Error fetching glbs.txt:', error);
    });

// A function to load and position all models
function loadModels(paths) {
    // Generate a new random seed for consistent positioning on each load
    const random = new THREE.Vector3();
    const radius = 100; // Radius for the circular distribution

    paths.forEach((path, index) => {
        // Generate a random position for each model
        const angle = (index / paths.length) * Math.PI * 2; // Distribute on a circle
        const x = Math.cos(angle) * (radius + Math.random() * 50);
        const y = Math.cos(angle) * (radius + Math.random() * 50);
        const z = Math.sin(angle) * (radius + Math.random() * 50);
        const position = new THREE.Vector3(x, y, z);

        loader.load(path, (gltf) => {
            const model = gltf.scene;
            model.position.copy(position);

            // Traverse the model's children and apply the new material
            model.traverse((child) => {
                if (child.isMesh) {
                    // child.material = newMaterial;
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(model);
            models.push(model);
            console.log(`Loaded model: ${path}`);
        }, undefined, (error) => {
            console.error(`Error loading model from ${path}`, error);
        });
    });
}   
       
        // --- 3. Animation and Manipulation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // This is the "livecoding" part!
            // Manipulate your models here. 
            // The 'models' array contains the loaded objects.

            if (models.length > 0) {
                // Example: Rotate all loaded models
                models.forEach(model => {
                    model.rotation.y += 0.005;
                    // You can add other manipulations like position or scale
                    // model.position.y = Math.sin(Date.now() * 0.001) * 0.5;
                });
            }

            controls.update(); // Required for OrbitControls damping
            renderer.render(scene, camera);
        }

        animate();

        // --- 4. Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>