<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livecoding GLB Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import essential three.js components
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Optional: Add camera controls for debugging
        // const controls = new OrbitControls(camera, renderer.domElement);
        // controls.enableDamping = true;
// --- 2. Load and Store Your Models ---
const loader = new GLTFLoader();
const allPaths = [];
const currentModels = [];
const displayGroupSize = 10; // Change this to 1 for showing one model at a time
let modelIndex = 0;
let lastUpdateTime = 0;
const slideInterval = 5000; // 5 seconds between slides

// A function to load and position models for the current window
function loadNextGroup() {
    // Clear the scene of old models
    currentModels.forEach(model => scene.remove(model));
    currentModels.length = 0;

    for (let i = 0; i < displayGroupSize; i++) {
        const pathIndex = (modelIndex + i) % allPaths.length;
        const path = allPaths[pathIndex];

        // Position models in a line for the sliding effect
    //    const position = new THREE.Vector3((i - (displayGroupSize - 1) / 2) * 5, 0, 0);
    const x = (Math.random() - 0.5) * 5;
                const y = (Math.random() - 0.5) * 2;
                const z = (Math.random() - 0.5) * 5;
                const position = new THREE.Vector3(x, y, z);
        loader.load(path, (gltf) => {
            const model = gltf.scene;
            model.position.copy(position);

            // Apply a material to avoid black meshes
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff * 0.7 });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(model);
            currentModels.push(model);
        });
    }

    modelIndex = (modelIndex + displayGroupSize) % allPaths.length;
}

// --- 3. Animation and Manipulation Loop ---
function animate(time) {
    requestAnimationFrame(animate);

    // Check if it's time to load the next group
    if (time - lastUpdateTime > slideInterval && allPaths.length > 0) {
        loadNextGroup();
        lastUpdateTime = time;
    }
    
    // Animate the camera orbit
    const orbitSpeed = 0.001; // Slower orbit speed
    const orbitRadius = 1;
    camera.position.x = Math.sin(time * orbitSpeed) * orbitRadius;
    camera.position.z = Math.cos(time * orbitSpeed) * orbitRadius;
    camera.lookAt(0, 0, 0);
    
    // Rotate the models
    currentModels.forEach(model => {model.rotation.y += 0.001; model.rotation.x += 0.001; model.rotation.z += 0.001});

    renderer.render(scene, camera);
}

// Start by fetching the paths and initializing the first group
fetch('glbs.txt')
    .then(response => response.text())
    .then(text => {
        const paths = text.split('\n').filter(path => path.trim() !== '');
        allPaths.push(...paths);
        loadNextGroup(); // Load the first group immediately
        animate(0);
    })
    .catch(error => console.error('Error fetching glbs.txt:', error));
        animate();

        // --- 4. Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>