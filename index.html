<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Room Tour</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #info-container {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            max-width: 350px;
        }

        #info-container h2 {
            margin-top: 0;
        }

        button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <div id="info-container">
        <h2 id="scene-title">Welcome!</h2>
        <p id="scene-description">Click the 'Next Scene' button to begin the tour of the rooms.</p>
    </div>
    <button id="next-btn">Next Scene</button>
    <canvas id="c"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { gsap } from 'gsap';

        // SCENE SETUP
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2a);

        // CAMERA
        const fov = 75;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.1;
        const far = 100;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 2, 28); // Starting position

        // LIGHTING
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // ROOM/CORRIDOR DIMENSIONS
        const roomWidth = 10;
        const roomDepth = 12;
        const roomHeight = 4;
        const corridorLength = 8;
        const wallThickness = 0.2;
        const humanHeight = 1.7; // Camera height

        // Reusable Materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

        // --- HELPER FUNCTIONS TO BUILD THE WORLD ---

        function createWall(w, h, d, position) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.copy(position);
            return wall;
        }

        function createFloor(w, d, position) {
            const geometry = new THREE.BoxGeometry(w, wallThickness, d);
            const floor = new THREE.Mesh(geometry, floorMaterial);
            floor.position.copy(position);
            return floor;
        }

        function createDoorway(position, wallWidth, wallHeight) {
            const doorWidth = 2;

            const doorHeight = 3;
            const group = new THREE.Group();

            // Left part of the wall
            const leftWidth = (wallWidth - doorWidth) / 2;
            const leftWall = createWall(leftWidth, wallHeight, wallThickness, new THREE.Vector3(-doorWidth / 2 - leftWidth / 2, wallHeight / 2, 0));
            group.add(leftWall);

            // Right part of the wall
            const rightWall = createWall(leftWidth, wallHeight, wallThickness, new THREE.Vector3(doorWidth / 2 + leftWidth / 2, wallHeight / 2, 0));
            group.add(rightWall);

            // Top part of the wall (lintel)
            const topHeight = wallHeight - doorHeight;
            const topWall = createWall(doorWidth, topHeight, wallThickness, new THREE.Vector3(0, doorHeight + topHeight / 2, 0));
            group.add(topWall);

            group.position.copy(position);
            return group;
        }

        function createRoom(positionZ, themeFunction) {
            const roomGroup = new THREE.Group();
            roomGroup.position.z = positionZ;

            // Floor
            const floor = createFloor(roomWidth, roomDepth, new THREE.Vector3(0, 0, 0));
            roomGroup.add(floor);

            // Back Wall
            const backWall = createWall(roomWidth, roomHeight, wallThickness, new THREE.Vector3(0, roomHeight / 2, -roomDepth / 2));
            roomGroup.add(backWall);

            // Left Wall
            const leftWall = createWall(wallThickness, roomHeight, roomDepth, new THREE.Vector3(-roomWidth / 2, roomHeight / 2, 0));
            roomGroup.add(leftWall);

            // Right Wall
            const rightWall = createWall(wallThickness, roomHeight, roomDepth, new THREE.Vector3(roomWidth / 2, roomHeight / 2, 0));
            roomGroup.add(rightWall);

            // Themed Content
            if (themeFunction) {
                const themedContent = themeFunction(roomWidth, roomHeight, roomDepth);
                roomGroup.add(themedContent);
            }

            scene.add(roomGroup);
        }

        function createCorridor(positionZ, hasFrontDoor = true, hasBackDoor = true) {
            const corridorGroup = new THREE.Group();
            corridorGroup.position.z = positionZ;

            // Corridor floor
            const floor = createFloor(roomWidth, corridorLength, new THREE.Vector3(0, 0, 0));
            corridorGroup.add(floor);

            // Corridor walls
            const leftWall = createWall(wallThickness, roomHeight, corridorLength, new THREE.Vector3(-roomWidth / 2, roomHeight / 2, 0));
            corridorGroup.add(leftWall);
            const rightWall = createWall(wallThickness, roomHeight, corridorLength, new THREE.Vector3(roomWidth / 2, roomHeight / 2, 0));
            corridorGroup.add(rightWall);

            // Doors
            if (hasFrontDoor) {
                const frontDoorWall = createDoorway(new THREE.Vector3(0, 0, corridorLength / 2), roomWidth, roomHeight);
                corridorGroup.add(frontDoorWall);
            }
            if (hasBackDoor) {
                const backDoorWall = createDoorway(new THREE.Vector3(0, 0, -corridorLength / 2), roomWidth, roomHeight);
                corridorGroup.add(backDoorWall);
            }

            scene.add(corridorGroup);
        }

        // --- ROOM THEME FUNCTIONS ---

        function createSolarpunkLivingRoom(w, h, d) {
            const group = new THREE.Group();

            // Bright floor
            const floor = new THREE.Mesh(new THREE.BoxGeometry(w, wallThickness, d), new THREE.MeshStandardMaterial({ color: 0x90ee90 }));
            floor.position.y = wallThickness; // place on top of base floor
            group.add(floor);

            // "Plant" placeholders (spheres and cylinders)

            const plantGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.2, 8);
            const plantMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const planter1 = new THREE.Mesh(plantGeo, plantMat);
            planter1.position.set(-w / 2 + 1, 0.6, -d / 2 + 1.5);
            group.add(planter1);

            const foliageGeo = new THREE.SphereGeometry(0.8, 8, 8);
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const foliage1 = new THREE.Mesh(foliageGeo, foliageMat);
            foliage1.position.set(-w / 2 + 1, 1.8, -d / 2 + 1.5);
            group.add(foliage1);

            // "Sofa" placeholder
            // const sofaGeo = new THREE.BoxGeometry(4, 1, 1.5);
            // const sofaMat = new THREE.MeshSolarStandardMaterial({ color: 0xF5F5DC });
            // const sofa = new THREE.Mesh(sofaGeo, sofaMat);
            // sofa.position.set(0, 0.5, d / 2 - 2);
            // group.add(sofa); // This is where you would load a couch.gltf

            
            // Bright light source
            const light = new THREE.PointLight(0xFFFFE0, 20, 15);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createCyberpunkKitchen(w, h, d) {
            const group = new THREE.Group();

            const floor = new THREE.Mesh(new THREE.BoxGeometry(w, wallThickness, d), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.4 }));
            floor.position.y = wallThickness;
            group.add(floor);

            // Neon light strips
            const neonGeo = new THREE.BoxGeometry(w * 0.8, 0.1, 0.1);
            const neonMatMagenta = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const neon1 = new THREE.Mesh(neonGeo, neonMatMagenta);
            neon1.position.set(0, h - 0.5, -d / 2 + 0.5);
            group.add(neon1);

            const neonMatCyan = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const neon2 = new THREE.Mesh(neonGeo, neonMatCyan);
            neon2.position.set(0, 0.5, d / 2 - 0.5);
            group.add(neon2);

            // "Counter" placeholder
            const counterGeo = new THREE.BoxGeometry(w, 1.2, 1.5);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.2 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter); // This is where you might load a kitchen_counter.gltf

            // Neon point light
            const light = new THREE.PointLight(0xff00ff, 50, 15);
            light.position.set(w / 2 - 2, h / 2, 0);
            group.add(light);

            return group;
        }

        function createMinimalistBedroom(w, h, d) {
            const group = new THREE.Group();

            const floor = new THREE.Mesh(new THREE.BoxGeometry(w, wallThickness, d), new THREE.MeshStandardMaterial({ color: 0xe0e0e0 }));
            floor.position.y = wallThickness;
            group.add(floor);

            // "Bed" placeholder
            const bedGeo = new THREE.BoxGeometry(2.5, 0.5, 3.5);
            const bedMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const bed = new THREE.Mesh(bedGeo, bedMat);
            bed.position.set(w / 2 - 2, 0.25, 0);
            group.add(bed); // This is where you might load a bed.gltf

            // "Dresser" placeholder
            const dresserGeo = new THREE.BoxGeometry(2, 1.5, 1);
            const dresserMat = new THREE.MeshStandardMaterial({ color: 0xbbbbbb });
            const dresser = new THREE.Mesh(dresserGeo, dresserMat);
            dresser.position.set(-w / 2 + 1.5, 0.75, 0);
            group.add(dresser);

            // Soft Light
            const light = new THREE.PointLight(0xffffff, 10, 20);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createArcadeShop(w, h, d) {
            const group = new THREE.Group();

            const floor = new THREE.Mesh(new THREE.BoxGeometry(w, wallThickness, d), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            floor.position.y = wallThickness;
            group.add(floor);

            // "Arcade Machine" placeholder
            function createArcade(x, z, color) {
                const arcadeGroup = new THREE.Group();
                const bodyGeo = new THREE.BoxGeometry(1, 1.8, 1.2);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.set(x, 0.9, z);

                const screenGeo = new THREE.PlaneGeometry(0.8, 0.6);
                const screenMat = new THREE.MeshBasicMaterial({ color: color });
                const screen = new THREE.Mesh(screenGeo, screenMat);
                screen.position.set(x, 1.2, z + 0.61);

                arcadeGroup.add(body, screen);
                return arcadeGroup; // This is where you might load arcade_machine.gltf
            }

            group.add(createArcade(-w / 2 + 1, -d / 2 + 2, 0x00ff00));
            group.add(createArcade(-w / 2 + 1, 0, 0xff00ff));
            group.add(createArcade(-w / 2 + 1, d / 2 - 2, 0xffff00));

            // Neon Sign placeholder
            const signGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const signMat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(w / 2 - 1, h - 1, 0);
            group.add(sign);
            const light = new THREE.PointLight(0xff4500, 40, 15);
            light.position.copy(sign.position);
            group.add(light);

            return group;
        }


        // --- BUILD THE WORLD LAYOUT ---
        // Z positions are calculated based on room/corridor sizes
        const startZ = 24;
        let currentZ = startZ; // Start in the first corridor

        // Corridor 1
        currentZ -= corridorLength / 2;
        createCorridor(currentZ, true, false); // Entrance corridor has one door
        currentZ -= corridorLength / 2;

        // Room 1: Solarpunk Living Room
        currentZ -= roomDepth / 2;
        const room1Z = currentZ;
        createRoom(room1Z, createSolarpunkLivingRoom);
        currentZ -= roomDepth / 2;

        // Corridor 2
        currentZ -= corridorLength / 2;
        createCorridor(currentZ);
        currentZ -= corridorLength / 2;

        // Room 2: Cyberpunk Kitchen
        currentZ -= roomDepth / 2;
        const room2Z = currentZ;
        createRoom(room2Z, createCyberpunkKitchen);
        currentZ -= roomDepth / 2;

        // Corridor 3
        currentZ -= corridorLength / 2;
        createCorridor(currentZ);
        currentZ -= corridorLength / 2;

        // Room 3: Minimalist Bedroom
        currentZ -= roomDepth / 2;
        const room3Z = currentZ;
        createRoom(room3Z, createMinimalistBedroom);
        currentZ -= roomDepth / 2;

        // Corridor 4
        currentZ -= corridorLength / 2;
        createCorridor(currentZ);
        currentZ -= corridorLength / 2;

        // Room 4: Arcade Shop
        currentZ -= roomDepth / 2;
        const room4Z = currentZ;
        createRoom(room4Z, createArcadeShop);
        currentZ -= roomDepth / 2;


        // --- CAMERA ANIMATION PATH ---
        const lookAtTarget = new THREE.Vector3(0, humanHeight, 0); // An object for the camera to look at
        camera.lookAt(lookAtTarget);

        const cameraPath = [
            { pos: new THREE.Vector3(0, humanHeight, startZ), lookAt: new THREE.Vector3(0, humanHeight, 0), title: "Corridor", desc: "Welcome to this procedural house. We are in the entrance corridor." },

            { pos: new THREE.Vector3(-2.5, humanHeight, room1Z + 2), lookAt: new THREE.Vector3(0, humanHeight, room1Z - 5), title: "Solarpunk Living Room", desc: "A bright, nature-inspired living space. Placeholders represent plants and furniture." },
            { pos: new THREE.Vector3(0, humanHeight, room1Z - corridorLength), lookAt: new THREE.Vector3(0, humanHeight, room1Z - corridorLength - 5), title: "Corridor", desc: "Moving to the next section." },
            { pos: new THREE.Vector3(2.5, humanHeight, room2Z + 2), lookAt: new THREE.Vector3(0, humanHeight, room2Z - 5), title: "Cyberpunk Kitchen", desc: "A dark kitchen with high-contrast neon lights. Materials have high metalness." },
            { pos: new THREE.Vector3(0, humanHeight, room2Z - corridorLength), lookAt: new THREE.Vector3(0, humanHeight, room2Z - corridorLength - 5), title: "Corridor", desc: "On our way to the bedroom." },
            { pos: new THREE.Vector3(0, humanHeight, room3Z + 4), lookAt: new THREE.Vector3(0, humanHeight, room3Z - 4), title: "Minimalist Bedroom", desc: "A clean, simple room with neutral colors and soft lighting." },
            { pos: new THREE.Vector3(0, humanHeight, room3Z - corridorLength), lookAt: new THREE.Vector3(0, humanHeight, room3Z - corridorLength - 5), title: "Corridor", desc: "Last stop: the arcade!" },
            { pos: new THREE.Vector3(2, humanHeight, room4Z + 2), lookAt: new THREE.Vector3(-3.5, 1.2, room4Z - 2), title: "Retro Arcade Shop", desc: "A fun room with placeholder arcade machines using emissive materials for their screens." },
        ];

        let currentSceneIndex = 0;
        const nextBtn = document.getElementById('next-btn');
        const titleEl = document.getElementById('scene-title');
        const descEl = document.getElementById('scene-description');

        function moveCamera() {
            nextBtn.disabled = true;
            const target = cameraPath[currentSceneIndex];

            gsap.to(camera.position, {
                x: target.pos.x,
                y: target.pos.y,
                z: target.pos.z,
                duration: 3,
                ease: 'power2.inOut'
            });

            gsap.to(lookAtTarget, {
                x: target.lookAt.x,
                y: target.lookAt.y,
                z: target.lookAt.z,
                duration: 3,
                ease: 'power2.inOut',
                onComplete: () => {
                    if (currentSceneIndex < cameraPath.length - 1) {
                        nextBtn.disabled = false;
                    } else {
                        nextBtn.innerText = "Tour Complete!";
                    }
                }
            });

            titleEl.innerText = target.title;
            descEl.innerText = target.desc;
        }

        nextBtn.addEventListener('click', () => {
            if (currentSceneIndex < cameraPath.length - 1) {
                currentSceneIndex++;
                moveCamera();
            }
        });

        // INITIAL STATE
        moveCamera(); // Move to the first position

        // RENDER LOOP & RESIZE HANDLER
        function animate() {
            requestAnimationFrame(animate);

            // Smoothly update lookAt target every frame
            camera.lookAt(lookAtTarget);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Set initial renderer size and start animation
        renderer.setSize(window.innerWidth, window.innerHeight);
        animate();

    </script>
</body>

</html>