<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Container City Explorer</title>
    <style>
        body {
            margin: 0;
            background-color: #050510;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #info-container {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            max-width: 350px;
        }

        #info-container h2 {
            margin-top: 0;
        }

        #controls-info {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
        }

        .mode-indicator {
            font-style: italic;
            font-weight: bold;
            color: #4ade80;
            transition: all 0.3s ease-in-out;
        }

        #nav-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
        }

        #auto-mode-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="info-container">
            <h2 id="scene-title">Welcome!</h2>
            <p id="scene-description">Use the arrow keys to explore the container city.</p>
        </div>
        <div id="controls-info">
            <p>Current Mode: <span id="current-mode" class="mode-indicator">Noclip (Free) Mode</span></p>
            <p style="margin: 5px 0;">
                <b>Tab</b>: Toggle camera mode.
            </p>
            <b>Noclip Controls:</b>
            <p style="margin: 5px 0;">
                <b>WASD / ZQSD</b> : Move.<br>
                <b>R / F</b> : Move Up / Down.<br>
                <b>Mouse Drag</b> : Look around.<br>
                <b>Shift</b>: Increase speed.
            </p>
            <hr style="border-color: rgba(255,255,255,0.2);">
            <b>Snap Controls:</b>
            <p style="margin: 5px 0;">
                <b>&uarr; / &darr; / &larr; / &rarr;</b> : Move between containers.
            </p>
        </div>
    </div>

    <div id="nav-controls">
        <label id="auto-mode-label">
            <input type="checkbox" id="auto-mode-checkbox">
            Auto Mode
        </label>
        <button id="next-btn">Next</button>
    </div>

    <canvas id="c"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { gsap } from 'gsap';

        // --- SCENE SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const lookAtTarget = new THREE.Vector3(0, 2, -5); // Target for snap mode
        camera.position.set(0, 2, 10);
        camera.lookAt(lookAtTarget);

        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 15);
        scene.add(directionalLight);

        // --- CORE VARIABLES ---
        const containerSize = new THREE.Vector3(8, 4, 10);
        const wallThickness = 0.2;
        const humanHeight = 1.7;
        let currentNodeIndex = 0;
        let isAnimating = false;
        let isAutoMode = false;
        const loader = new GLTFLoader();

        // --- UI ELEMENTS ---
        const nextBtn = document.getElementById('next-btn');
        const autoModeCheckbox = document.getElementById('auto-mode-checkbox');
        const titleEl = document.getElementById('scene-title');
        const descEl = document.getElementById('scene-description');
        const modeIndicator = document.getElementById('current-mode');

        // --- CAMERA CONTROLS (Noclip) ---
        let isNoclipMode = true;
        let noclipKeys = {};
        let isShiftPressed = false;
        let mouseDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        const rotationSpeed = 0.002;
        let cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
        const noclipMoveSpeed = 0.1;
        const noclipMaxMoveSpeed = 0.5;

        // --- CITY LAYOUT DEFINITION ---
        const cityLayout = [
            { id: 0, pos: new THREE.Vector3(0, 0, 0), theme: createNoodleShop, title: "Noodle Shop", desc: "A cozy noodle shop. The steam warms the cold metal walls.", connections: { north: 1 } },
            { id: 1, pos: new THREE.Vector3(0, 0, -12), theme: createLivingQuarters, title: "Living Quarters", desc: "A cramped but functional living space.", connections: { south: 0, up: 2 } },
            { id: 2, pos: new THREE.Vector3(0, 5, -12), theme: createArcade, title: "Mini Arcade", desc: "A noisy, flashing escape from the quiet hum of the city.", connections: { down: 1, west: 3, east: 4 } },
            { id: 3, pos: new THREE.Vector3(-10, 5, -12), theme: createCafe, title: "Container Cafe", desc: "The aroma of coffee lingers in the air. A place to relax and recharge.", connections: { east: 2 } },
            { id: 4, pos: new THREE.Vector3(10, 5, -12), theme: createHydroponics, title: "Hydroponics Bay", desc: "The source of fresh greens, glowing under purple lights.", connections: { west: 2, north: 5 } },
            { id: 5, pos: new THREE.Vector3(10, 5, -24), theme: createStorage, title: "Storage Room", desc: "A disorganized pile of old stuff and forgotten crates.", connections: { south: 4, up: 6 } },
            { id: 6, pos: new THREE.Vector3(10, 10, -24), theme: createLookout, title: "Lookout Point", desc: "A vantage point overlooking the foggy, sprawling container city below.", connections: { down: 5 } },
        ];

        // --- ASSET LOADING HELPER ---
        function loadAsset(group, path, pos, scale, rot) {
            loader.load(
                path,
                (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(scale.x, scale.y, scale.z);
                    model.position.set(pos.x, pos.y, pos.z);
                    model.rotation.set(rot.x, rot.y, rot.z);
                    group.add(model);
                },
                undefined,
                (error) => console.error(`Failed to load model at ${path}`, error)
            );
        }

        // --- CONTAINER CREATION LOGIC ---
        function createContainer(node) {
            const group = new THREE.Group();
            group.position.copy(node.pos);

            const containerMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5 });

            const doorSize = { width: 2, height: 3 };

            const createWall = (size, position, rotation, connection) => {
                if (connection !== undefined && connection !== null) {
                    const wallGroup = new THREE.Group();
                    const wallW = size.x > size.z ? size.x : size.z;
                    const sideWidth = (wallW - doorSize.width) / 2;
                    const leftGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const leftMesh = new THREE.Mesh(leftGeo, containerMat);
                    leftMesh.position.x = -(doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(leftMesh);
                    const rightGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const rightMesh = new THREE.Mesh(rightGeo, containerMat);
                    rightMesh.position.x = (doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(rightMesh);
                    const topHeight = size.y - doorSize.height;
                    if (topHeight > 0) {
                        const topGeo = new THREE.BoxGeometry(doorSize.width, topHeight, wallThickness);
                        const topMesh = new THREE.Mesh(topGeo, containerMat);
                        topMesh.position.y = doorSize.height / 2 + topHeight / 2;
                        wallGroup.add(topMesh);
                    }
                    wallGroup.position.copy(position);
                    wallGroup.rotation.y = rotation;
                    return wallGroup;
                } else {
                    const wallGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const wallMesh = new THREE.Mesh(wallGeo, containerMat);
                    wallMesh.position.copy(position);
                    wallMesh.rotation.y = rotation;
                    return wallMesh;
                }
            };

            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, containerSize.z / 2), 0, node.connections.north));
            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, -containerSize.z / 2), 0, node.connections.south));
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.east));
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(-containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.west));

            const floorGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const floor = new THREE.Mesh(floorGeo, containerMat);
            floor.position.y = 0;
            group.add(floor);

            const ceilingGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const ceiling = new THREE.Mesh(ceilingGeo, containerMat);
            ceiling.position.y = containerSize.y;
            group.add(ceiling);

            // Add a default dim light to every container to avoid total darkness
            const defaultLight = new THREE.PointLight(0x333344, 5, 10);
            defaultLight.position.set(0, containerSize.y - 1, 0);
            group.add(defaultLight);

            if (node.theme) {
                const themedContent = node.theme(containerSize.x, containerSize.y, containerSize.z);
                group.add(themedContent);
            }

            scene.add(group);
        }

        // --- THEME FUNCTIONS (Populate containers) ---
        function createNoodleShop(w, h, d) {
            const group = new THREE.Group();
            const counterGeo = new THREE.BoxGeometry(w * 0.8, 1.2, 1);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter);

            loadAsset(group, 'assets/furnitures/stoolBar.glb', new THREE.Vector3(-1.5, 0, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/stoolBar.glb', new THREE.Vector3(1.5, 0, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            loadAsset(group, 'assets/food/bowl-broth.glb', new THREE.Vector3(-1.5, 1.2, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/chopstick.glb', new THREE.Vector3(-1.5, 1.2, 0.8), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, Math.PI, Math.PI / 2));
            loadAsset(group, 'assets/food/bowl-broth.glb', new THREE.Vector3(1.5, 1.2, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/chopstick.glb', new THREE.Vector3(1.5, 1.2, 0.8), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, Math.PI, Math.PI / 2));

            const light = new THREE.PointLight(0xffa500, 50, 8);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }

        function createLivingQuarters(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/cyberpunk/sofa_couch.glb', new THREE.Vector3(-w / 2 + 2, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/tableCoffee.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/televisionModern.glb', new THREE.Vector3(w / 2 - 1, 0.8, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/books.glb', new THREE.Vector3(w / 2 - 1, 1.4, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/pottedPlant.glb', new THREE.Vector3(-w / 2 + 1, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));


            const light = new THREE.PointLight(0xeeeeff, 25, 12);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createCafe(w, h, d) {
            const group = new THREE.Group();
            loadAsset(group, 'assets/furnitures/tableRound.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/chair.glb', new THREE.Vector3(0, 0, -2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/chair.glb', new THREE.Vector3(0, 0, 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/food/cup-coffee.glb', new THREE.Vector3(0, 0.7, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/donut-chocolate.glb', new THREE.Vector3(0, 0.7, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, 0, 0));

            const counterGeo = new THREE.BoxGeometry(w * 0.8, 1.2, 1.5);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x964B00 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter);

            loadAsset(group, 'assets/food/cup-coffee.glb', new THREE.Vector3(0, 1.2, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            const light = new THREE.PointLight(0xffddaa, 30, 10);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createArcade(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/arcade/pinball.glb', new THREE.Vector3(-w / 4, 0, -d / 2 + 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/arcade/arcade-machine.glb', new THREE.Vector3(w / 4, 0, -d / 2 + 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/arcade/claw-machine.glb', new THREE.Vector3(w / 2 - 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/arcade/prizes.glb', new THREE.Vector3(w / 2 - 1, 0.8, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));

            const light = new THREE.PointLight(0x00ffff, 40, 10);
            light.position.set(0, h / 2, 0);
            group.add(light);
            return group;
        }

        function createHydroponics(w, h, d) {
            const group = new THREE.Group();

            for (let i = 0; i < 4; i++) {
                loadAsset(group, 'assets/furnitures/pottedPlant.glb', new THREE.Vector3(0, 0, -d / 2 + 1 + i * 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            }

            const light = new THREE.PointLight(0xff00ff, 80, 12);
            light.position.set(0, h - 0.5, 0);
            group.add(light);
            return group;
        }

        function createStorage(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/urban/pallet.glb', new THREE.Vector3(-1.5, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/pallet.glb', new THREE.Vector3(1.5, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/cardboardBoxOpen.glb', new THREE.Vector3(-1.5, 0.1, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/cardboardBoxClosed.glb', new THREE.Vector3(1.5, 0.1, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/trashcan.glb', new THREE.Vector3(-w / 2 + 1, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            const light = new THREE.PointLight(0xaaaaaa, 20, 15);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }

        function createLookout(w, h, d) {
            const group = new THREE.Group();
            loadAsset(group, 'assets/urban/detail-barrier-strong-type-a.glb', new THREE.Vector3(0, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/detail-bench.glb', new THREE.Vector3(w / 2 - 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/urban/detail-light-single.glb', new THREE.Vector3(-w / 2 + 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI / 2, 0));

            const light = new THREE.PointLight(0x6677aa, 20, 15);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }


        // --- NAVIGATION & ANIMATION (Snap Mode) ---
        function navigateToNode(nodeIndex) {
            if (isAnimating || nodeIndex === null || nodeIndex === undefined) return;
            isAnimating = true;
            currentNodeIndex = nodeIndex;

            const targetNode = cityLayout.find(n => n.id === nodeIndex);
            if (!targetNode) {
                isAnimating = false;
                return;
            }

            titleEl.innerText = targetNode.title;
            descEl.innerText = targetNode.desc;
            nextBtn.disabled = true;

            const cameraPos = new THREE.Vector3(
                targetNode.pos.x,
                targetNode.pos.y + humanHeight,
                targetNode.pos.z + containerSize.z * 0.4
            );

            let lookAtPos;
            const primaryDirection = targetNode.connections.north ?? targetNode.connections.east ?? targetNode.connections.south ?? targetNode.connections.west ?? null;
            if (primaryDirection !== null) {
                const nextNode = cityLayout.find(n => n.id === primaryDirection);
                if (nextNode) {
                    lookAtPos = new THREE.Vector3(nextNode.pos.x, nextNode.pos.y + humanHeight, nextNode.pos.z);
                }
            }

            if (!lookAtPos) {
                lookAtPos = new THREE.Vector3(targetNode.pos.x, targetNode.pos.y + humanHeight, targetNode.pos.z - 5);
            }
            
            gsap.to(camera.position, { ...cameraPos, duration: 1.5, ease: 'power2.inOut' });
            gsap.to(lookAtTarget, {
                ...lookAtPos,
                duration: 1.5,
                ease: 'power2.inOut',
                onComplete: () => {
                    isAnimating = false;
                    if (isAutoMode) nextBtn.disabled = false;
                }
            });
        }

        // --- EVENT LISTENERS ---
        function handleNoclipMovement() {
            const speed = isShiftPressed ? noclipMaxMoveSpeed : noclipMoveSpeed;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

            if (noclipKeys['w'] || noclipKeys['z']) {
                camera.position.add(forward.multiplyScalar(speed));
            }
            if (noclipKeys['s']) {
                camera.position.sub(forward.multiplyScalar(speed));
            }
            if (noclipKeys['a'] || noclipKeys['q']) {
                camera.position.sub(right.multiplyScalar(speed));
            }
            if (noclipKeys['d']) {
                camera.position.add(right.multiplyScalar(speed));
            }
            if (noclipKeys['r']) {
                camera.position.y += speed;
            }
            if (noclipKeys['f']) {
                camera.position.y -= speed;
            }
        }
        
        function handleSnapMovement(event) {
            if (isAnimating || isAutoMode) return;

            const currentNode = cityLayout.find(n => n.id === currentNodeIndex);
            let nextNodeId = null;

            switch (event.key) { // Check for the key's name, which includes "Arrow"
                case 'ArrowUp':
                    nextNodeId = currentNode.connections.north;
                    break;
                case 'ArrowDown':
                    nextNodeId = currentNode.connections.south;
                    break;
                case 'ArrowLeft':
                    nextNodeId = currentNode.connections.west;
                    break;
                case 'ArrowRight':
                    nextNodeId = currentNode.connections.east;
                    break;
            }

            if (nextNodeId !== undefined && nextNodeId !== null) {
                navigateToNode(nextNodeId);
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                isNoclipMode = !isNoclipMode;
                modeIndicator.textContent = isNoclipMode ? 'Noclip (Free) Mode' : 'Snap (Container) Mode';
                
                if (!isNoclipMode) {
                    const currentNode = cityLayout.find(n => n.id === currentNodeIndex);
                    if (currentNode) {
                         const cameraPos = new THREE.Vector3(
                            currentNode.pos.x,
                            currentNode.pos.y + humanHeight,
                            currentNode.pos.z + containerSize.z * 0.4
                        );
                        gsap.to(camera.position, { ...cameraPos, duration: 0.5, ease: 'power2.inOut' });
                        canvas.style.cursor = 'default';
                    }
                } else {
                    canvas.style.cursor = 'grab';
                }
            }

            if (isNoclipMode) {
                noclipKeys[e.key.toLowerCase()] = true;
                if (e.key === 'Shift') {
                    isShiftPressed = true;
                }
            } else {
                handleSnapMovement(e);
            }
        });

        window.addEventListener('keyup', (e) => {
            noclipKeys[e.key.toLowerCase()] = false;
            if (e.key === 'Shift') {
                isShiftPressed = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (isNoclipMode) {
                mouseDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDragging = false;
            if(isNoclipMode) {
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDragging && isNoclipMode) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                cameraRotation.y -= deltaX * rotationSpeed;
                cameraRotation.x -= deltaY * rotationSpeed;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                camera.quaternion.setFromEuler(cameraRotation);
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        nextBtn.addEventListener('click', () => {
            if (isAutoMode && !isAnimating) {
                let nextIndex = (currentNodeIndex + 1) % cityLayout.length;
                navigateToNode(nextIndex);
            }
        });

        autoModeCheckbox.addEventListener('change', (e) => {
            isAutoMode = e.target.checked;
            nextBtn.disabled = !isAutoMode;
            nextBtn.style.opacity = isAutoMode ? '1' : '0.5';
        });

        // --- INITIALIZATION ---
        function buildWorld() {
            cityLayout.forEach(node => createContainer(node));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);

            if (isNoclipMode) {
                handleNoclipMovement();
            } else {
                camera.lookAt(lookAtTarget);
            }

            renderer.render(scene, camera);
        }

        buildWorld();
        navigateToNode(0);
        autoModeCheckbox.checked = false;
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.5';
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvas.style.cursor = 'grab';
        
        setTimeout(() => {
            animate();
        }, 100);
    </script>
</body>

</html>
