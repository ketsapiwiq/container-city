<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Container City Explorer</title>
    <style>
        body {
            margin: 0;
            background-color: #050510;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #info-container {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            max-width: 350px;
        }

        #info-container h2 {
            margin-top: 0;
        }

        #controls-info {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
        }

        #nav-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
        }

        #auto-mode-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="info-container">
            <h2 id="scene-title">Welcome!</h2>
            <p id="scene-description">Use the arrow keys to explore the container city.</p>
        </div>
        <div id="controls-info">
            <b>Controls:</b>
            <p style="margin: 5px 0;">
                <b>&uarr; / &darr; / &larr; / &rarr;</b> : Move between containers.<br>
                <b>W / S</b> : Move Forward / Backward.
            </p>
        </div>
    </div>

    <div id="nav-controls">
        <label id="auto-mode-label">
            <input type="checkbox" id="auto-mode-checkbox">
            Auto Mode
        </label>
        <button id="next-btn">Next</button>
    </div>

    <canvas id="c"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { gsap } from 'gsap';

        // --- SCENE SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const lookAtTarget = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 2, 10);
        camera.lookAt(lookAtTarget);

        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 15);
        scene.add(directionalLight);

        // --- CORE VARIABLES ---
        const containerSize = new THREE.Vector3(8, 4, 10);
        const wallThickness = 0.2;
        const humanHeight = 1.7;
        let currentNodeIndex = 0;
        let isAnimating = false;
        let isAutoMode = false;

        // --- UI ELEMENTS ---
        const nextBtn = document.getElementById('next-btn');
        const autoModeCheckbox = document.getElementById('auto-mode-checkbox');
        const titleEl = document.getElementById('scene-title');
        const descEl = document.getElementById('scene-description');

        // --- CITY LAYOUT DEFINITION ---
        // This is the "map" of our city. Each object is a container node.
        // Connections link nodes by their ID.
        const cityLayout = [
            { id: 0, pos: new THREE.Vector3(0, 0, 0), theme: createNoodleShop, title: "Noodle Shop", desc: "A cozy noodle shop. The steam warms the cold metal walls.", connections: { north: 1 } },
            { id: 1, pos: new THREE.Vector3(0, 0, -12), theme: createLivingQuarters, title: "Living Quarters", desc: "A cramped but functional living space.", connections: { south: 0, east: 2, up: 3 } },
            { id: 2, pos: new THREE.Vector3(10, 0, -12), theme: createArcade, title: "Mini Arcade", desc: "A noisy, flashing escape from the quiet hum of the city.", connections: { west: 1 } },
            { id: 3, pos: new THREE.Vector3(0, 5, -12), theme: createHydroponics, title: "Hydroponics Bay", desc: "The source of fresh greens, glowing under purple lights.", connections: { down: 1, north: 4 } },
            { id: 4, pos: new THREE.Vector3(0, 5, -24), theme: null, title: "Empty Container", desc: "This container is cold and empty. A faint breeze comes from an opening above.", connections: { south: 3, up: 5 } },
            { id: 5, pos: new THREE.Vector3(0, 10, -24), theme: createLookout, title: "Lookout Point", desc: "A vantage point overlooking the foggy, sprawling container city below.", connections: { down: 4 } },
        ];

        // --- CONTAINER CREATION LOGIC ---
        function createContainer(node) {
            const group = new THREE.Group();
            group.position.copy(node.pos);

            const containerMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5 });

            const doorSize = { width: 2, height: 3 };

            // Helper to create a wall with a potential opening
            const createWall = (size, position, rotation, connection) => {
                if (connection !== undefined && connection !== null) {
                    // Wall with doorway
                    const wallGroup = new THREE.Group();
                    const wallW = size.x > size.z ? size.x : size.z;
                    const sideWidth = (wallW - doorSize.width) / 2;

                    // Left part
                    const leftGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const leftMesh = new THREE.Mesh(leftGeo, containerMat);
                    leftMesh.position.x = -(doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(leftMesh);

                    // Right part
                    const rightGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const rightMesh = new THREE.Mesh(rightGeo, containerMat);
                    rightMesh.position.x = (doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(rightMesh);

                    // Top part
                    const topHeight = size.y - doorSize.height;
                    if (topHeight > 0) {
                        const topGeo = new THREE.BoxGeometry(doorSize.width, topHeight, wallThickness);
                        const topMesh = new THREE.Mesh(topGeo, containerMat);
                        topMesh.position.y = doorSize.height / 2 + topHeight / 2;
                        wallGroup.add(topMesh);
                    }
                    wallGroup.position.copy(position);
                    wallGroup.rotation.y = rotation;
                    return wallGroup;
                } else {
                    // Solid wall
                    const wallGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const wallMesh = new THREE.Mesh(wallGeo, containerMat);
                    wallMesh.position.copy(position);
                    wallMesh.rotation.y = rotation;
                    return wallMesh;
                }
            };

            // Create walls based on connections
            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, containerSize.z / 2), 0, node.connections.north)); // Front (North)
            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, -containerSize.z / 2), 0, node.connections.south)); // Back (South)
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.east)); // Right (East)
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(-containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.west)); // Left (West)

            // Floor and Ceiling
            const floorGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const floor = new THREE.Mesh(floorGeo, containerMat);
            floor.position.y = 0;
            group.add(floor);

            const ceilingGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const ceiling = new THREE.Mesh(ceilingGeo, containerMat);
            ceiling.position.y = containerSize.y;
            group.add(ceiling);


            // Add themed content if it exists
            if (node.theme) {
                const themedContent = node.theme(containerSize.x, containerSize.y, containerSize.z);
                group.add(themedContent);
            }

            scene.add(group);
        }

        // --- THEME FUNCTIONS (Populate containers) ---
        function createNoodleShop(w, h, d) {
            const group = new THREE.Group();
            const counterGeo = new THREE.BoxGeometry(w * 0.8, 1.2, 1);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter);

            const light = new THREE.PointLight(0xffa500, 50, 8);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }

        function createLivingQuarters(w, h, d) {
            const group = new THREE.Group();
            const loader = new GLTFLoader();
            loader.load(
                'https://storage.googleapis.com/sp-ar-assets/couch-b883389a-2830-449e-824b-653716631835/couch.glb',
                (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(1.2, 1.2, 1.2);
                    model.position.set(-w / 2 + 2, 0.2, 0);
                    model.rotation.y = Math.PI / 2;
                    group.add(model);
                },
                undefined,
                (error) => {
                    console.error('Failed to load couch model', error);
                    const fallbackBed = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, d * 0.6), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
                    fallbackBed.position.set(-w / 2 + 1, 0.4, 0);
                    group.add(fallbackBed);
                }
            );
            return group;
        }

        function createArcade(w, h, d) {
            const group = new THREE.Group();
            const arcadeGeo = new THREE.BoxGeometry(1, 1.8, 1.2);
            const arcadeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const arcade1 = new THREE.Mesh(arcadeGeo, arcadeMat);
            arcade1.position.set(w / 2 - 1.5, 0.9, -2);
            group.add(arcade1);

            const screenGeo = new THREE.PlaneGeometry(0.8, 0.6);
            const screenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const screen1 = new THREE.Mesh(screenGeo, screenMat);
            screen1.position.set(w / 2 - 1.5, 1.2, -2 + 0.61);
            group.add(screen1);

            const light = new THREE.PointLight(0x00ffff, 40, 10);
            light.position.set(0, h / 2, 0);
            group.add(light);
            return group;
        }

        function createHydroponics(w, h, d) {
            const group = new THREE.Group();
            const planterGeo = new THREE.BoxGeometry(w * 0.8, 0.5, 1);
            const planterMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            for (let i = 0; i < 4; i++) {
                const planter = new THREE.Mesh(planterGeo, planterMat);
                planter.position.set(0, 0.25, -d / 2 + 1 + i * 2);
                group.add(planter);
            }
            const light = new THREE.PointLight(0xff00ff, 80, 12);
            light.position.set(0, h - 0.5, 0);
            group.add(light);
            return group;
        }

        function createLookout(w, h, d) {
            const group = new THREE.Group();
            // This container is mostly empty to provide a view.
            // We can add a simple railing.
            const railGeo = new THREE.BoxGeometry(w, 0.1, 0.1);
            const railMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const rail = new THREE.Mesh(railGeo, railMat);
            rail.position.set(0, 1, -d / 2 + 0.5);
            group.add(rail);
            return group;
        }


        // --- NAVIGATION & ANIMATION ---
        function navigateToNode(nodeIndex) {
            if (isAnimating || nodeIndex === null || nodeIndex === undefined) return;
            isAnimating = true;
            currentNodeIndex = nodeIndex;

            const targetNode = cityLayout.find(n => n.id === nodeIndex);
            if (!targetNode) {
                isAnimating = false;
                return;
            }

            // Update UI
            titleEl.innerText = targetNode.title;
            descEl.innerText = targetNode.desc;
            nextBtn.disabled = true;

            const cameraPos = new THREE.Vector3(
                targetNode.pos.x,
                targetNode.pos.y + humanHeight,
                targetNode.pos.z + containerSize.z * 0.4
            );

            // Determine a smart look-at target
            const nextNodeDir = Object.keys(targetNode.connections).find(key => targetNode.connections[key] !== null);
            let lookAtPos;
            if (nextNodeDir) {
                const nextNode = cityLayout.find(n => n.id === targetNode.connections[nextNodeDir]);
                if (nextNode) {
                    lookAtPos = new THREE.Vector3(
                        nextNode.pos.x,
                        nextNode.pos.y + humanHeight,
                        nextNode.pos.z
                    );
                }
            }
            // Fallback look-at
            if (!lookAtPos) {
                lookAtPos = new THREE.Vector3(targetNode.pos.x, targetNode.pos.y + humanHeight, targetNode.pos.z - 5);
            }


            gsap.to(camera.position, {
                ...cameraPos,
                duration: 1.5,
                ease: 'power2.inOut'
            });

            gsap.to(lookAtTarget, {
                ...lookAtPos,
                duration: 1.5,
                ease: 'power2.inOut',
                onComplete: () => {
                    isAnimating = false;
                    if (isAutoMode) nextBtn.disabled = false;
                }
            });
        }

        // --- EVENT LISTENERS ---
        function handleKeyDown(event) {
            if (isAnimating || isAutoMode) return;

            const currentNode = cityLayout.find(n => n.id === currentNodeIndex);
            let nextNodeId = null;

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    nextNodeId = currentNode.connections.north;
                    break;
                case 'ArrowDown':
                case 's':
                    nextNodeId = currentNode.connections.south;
                    break;
                case 'ArrowLeft':
                    nextNodeId = currentNode.connections.west;
                    break;
                case 'ArrowRight':
                    nextNodeId = currentNode.connections.east;
                    break;
                // You could add Q/E for up/down if you prefer
                // case 'q': nextNodeId = currentNode.connections.down; break;
                // case 'e': nextNodeId = currentNode.connections.up; break;
            }

            // Special handling for up/down on specific nodes for clarity
            if (currentNode.id === 1 && event.key === 'ArrowUp') nextNodeId = currentNode.connections.up;
            if (currentNode.id === 3 && event.key === 'ArrowDown') nextNodeId = currentNode.connections.down;
            if (currentNode.id === 3 && event.key === 'w') nextNodeId = currentNode.connections.north;
            if (currentNode.id === 4 && event.key === 'ArrowUp') nextNodeId = currentNode.connections.up;
            if (currentNode.id === 5 && event.key === 'ArrowDown') nextNodeId = currentNode.connections.down;


            if (nextNodeId !== null) {
                navigateToNode(nextNodeId);
            }
        }

        window.addEventListener('keydown', handleKeyDown);

        nextBtn.addEventListener('click', () => {
            if (isAutoMode && !isAnimating) {
                let nextIndex = (currentNodeIndex + 1) % cityLayout.length;
                navigateToNode(nextIndex);
            }
        });

        autoModeCheckbox.addEventListener('change', (e) => {
            isAutoMode = e.target.checked;
            nextBtn.disabled = !isAutoMode;
            nextBtn.style.opacity = isAutoMode ? '1' : '0.5';
        });


        // --- INITIALIZATION ---
        function buildWorld() {
            cityLayout.forEach(node => createContainer(node));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);
            camera.lookAt(lookAtTarget);
            renderer.render(scene, camera);
        }

        buildWorld();
        navigateToNode(0);
        autoModeCheckbox.checked = false; // Start in manual mode
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.5';
        renderer.setSize(window.innerWidth, window.innerHeight);
        animate();

    </script>
</body>

</html>