Add more rooms and stuff them with more items, make it be maybe a 3x3x3 containers (27) box? its supposed to be kowloon city: <!DOCTYPE html>

Here are assets u can use (kenney packs) for these rooms:
assets/arcade:
air-hockey.glb character-employee.glb dance-machine.glb prize-wheel.glb vending-machine.glb wall.glb
arcade-machine.glb character-gamer.glb floor.glb prizes.glb wall-corner.glb
basketball-game.glb claw-machine.glb gambling-machine.glb Textures wall-door-rotate.glb
cash-register.glb column.glb pinball.glb ticket-machine.glb wall-window.glb

assets/cyberpunk:
sofa_couch.glb

assets/food:
advocado-half.glb cherries.glb frikandel-speciaal.glb mussel.glb sausage.glb
apple-half.glb chinese.glb frying-pan-lid.glb onion-half.glb shaker-pepper.glb
apple.glb chocolate-wrapper.glb frying-pan.glb onion.glb shaker-salt.glb
avocado.glb chocolate.glb ginger-bread-cutter.glb orange.glb skewer-vegetables.glb
bacon-raw.glb chopstic-decorative.glb ginger-bread.glb pan-stew.glb skewer.glb
bacon.glb chopstick.glb glass-wine.glb pan.glb soda-bottle.glb
bag-flat.glb cocktail.glb glass.glb pancakes.glb soda-can-crushed.glb
bag.glb coconut-half.glb grapes.glb paprika-slice.glb soda-can.glb
banana.glb coconut.glb honey.glb paprika.glb soda-glass.glb
barrel.glb cookie-chocolate.glb hot-dog-raw.glb peanut-butter.glb soda.glb
beet.glb cookie.glb hot-dog.glb pear-half.glb soy.glb
bottle-ketchup.glb cooking-fork.glb ice-cream-cne.glb pear.glb steamer.glb
bottle-musterd.glb cooking-knife-chopping.glb ice-cream-cup.glb pepper-mill.glb strawberry.glb
bottle-oil.glb cooking-knife.glb ice-cream-scoop-chocolate.glb pepper.glb styrofoam-dinner.glb
bowl-broth.glb cooking-spatula.glb ice-cream-scoop-mint.glb pie.glb styrofoam.glb
bowl-cereal.glb cooking-spoon.glb ice-cream.glb pineapple.glb sub.glb
bowl-soup.glb corn-dog.glb knife-block.glb pizza-box.glb sundae.glb
bowl.glb corn.glb leek.glb pizza-cutter.glb sushi-egg.glb
bread.glb croissant.glb lemon-half.glb pizza.glb sushi-salmon.glb
broccoli.glb cup-coffee.glb lemon.glb plate-broken.glb taco.glb
burger-cheese-double.glb cup-saucer.glb loaf-baguette.glb plate-deep.glb tajine-lid.glb
burger-cheese.glb cup-tea.glb loaf-round.glb plate-dinner.glb tajine.glb
burger-double.glb cup.glb loaf.glb plate-rectangle.glb Textures
burger.glb cupcake.glb lollypop.glb plate-sauerkraut.glb tomato-slice.glb
cabbage.glb cutting-board-japanese.glb maki-roe.glb plate.glb tomato.glb
cake-birthday.glb cutting-board-round.glb maki-salmon.glb popsicle-chocolate.glb turkey.glb
cake-slicer.glb cutting-board.glb maki-vegetable.glb popsicle-stick.glb utensil-fork.glb
cake.glb dim-sum.glb meat-cooked.glb popsicle.glb utensil-knife.glb
can-open.glb donut-chocolate.glb meat-patty.glb pot-lid.glb utensil-spoon.glb
can-small.glb donut-sprinkles.glb meat-raw.glb pot-stew-lid.glb waffle.glb
can.glb donut.glb meat-ribs.glb pot-stew.glb watermelon.glb
candy-bar-wrapper.glb egg-cooked.glb meat-sausage.glb pot.glb whipped-cream.glb
candy-bar.glb egg-cup.glb meat-tenderizer.glb pudding.glb whisk.glb
carrot.glb egg-half.glb mincemeat-pie.glb pumpkin-basic.glb whole-ham.glb
carton-small.glb egg.glb mortar-pestle.glb pumpkin.glb wholer-ham.glb
carton.glb eggplant.glb mortar.glb radish.glb wine-red.glb
cauliflower.glb fish-bones.glb muffin.glb rice-ball.glb wine-white.glb
celery-stick.glb fish.glb mug.glb rollingPin.glb
cheese-cut.glb frappe.glb mushroom-half.glb salad.glb
cheese-slicer.glb fries-empty.glb mushroom.glb sandwich.glb
cheese.glb fries.glb mussel-open.glb sausage-half.glb

assets/furnitures:
bathroomCabinet.glb computerKeyboard.glb lampRoundFloor.glb speaker.glb
bathroomCabinetDrawer.glb computerMouse.glb lampRoundTable.glb speakerSmall.glb
bathroomMirror.glb computerScreen.glb lampSquareCeiling.glb stairs.glb
bathroomSink.glb desk.glb lampSquareFloor.glb stairsCorner.glb
bathroomSinkSquare.glb deskCorner.glb lampSquareTable.glb stairsOpen.glb
bathtub.glb doorway.glb lampWall.glb stairsOpenSingle.glb
bear.glb doorwayFront.glb laptop.glb stoolBar.glb
bedBunk.glb doorwayOpen.glb loungeChair.glb stoolBarSquare.glb
bedDouble.glb dryer.glb loungeChairRelax.glb table.glb
bedSingle.glb floorCorner.glb loungeDesignChair.glb tableCloth.glb
bench.glb floorCornerRound.glb loungeDesignSofa.glb tableCoffee.glb
benchCushion.glb floorFull.glb loungeDesignSofaCorner.glb tableCoffeeGlass.glb
benchCushionLow.glb floorHalf.glb loungeSofa.glb tableCoffeeGlassSquare.glb
bookcaseClosed.glb hoodLarge.glb loungeSofaCorner.glb tableCoffeeSquare.glb
bookcaseClosedDoors.glb hoodModern.glb loungeSofaLong.glb tableCross.glb
bookcaseClosedWide.glb kitchenBar.glb loungeSofaOttoman.glb tableCrossCloth.glb
bookcaseOpen.glb kitchenBarEnd.glb paneling.glb tableGlass.glb
bookcaseOpenLow.glb kitchenBlender.glb pillow.glb tableRound.glb
books.glb kitchenCabinet.glb pillowBlue.glb televisionAntenna.glb
cabinetBed.glb kitchenCabinetCornerInner.glb pillowBlueLong.glb televisionModern.glb
cabinetBedDrawer.glb kitchenCabinetCornerRound.glb pillowLong.glb televisionVintage.glb
cabinetBedDrawerTable.glb kitchenCabinetDrawer.glb plantSmall1.glb toaster.glb
cabinetTelevision.glb kitchenCabinetUpper.glb plantSmall2.glb toilet.glb
cabinetTelevisionDoors.glb kitchenCabinetUpperCorner.glb plantSmall3.glb toiletSquare.glb
cardboardBoxClosed.glb kitchenCabinetUpperDouble.glb pottedPlant.glb trashcan.glb
cardboardBoxOpen.glb kitchenCabinetUpperLow.glb radio.glb wall.glb
ceilingFan.glb kitchenCoffeeMachine.glb rugDoormat.glb wallCorner.glb
chair.glb kitchenFridge.glb rugRectangle.glb wallCornerRond.glb
chairCushion.glb kitchenFridgeBuiltIn.glb rugRound.glb wallDoorway.glb
chairDesk.glb kitchenFridgeLarge.glb rugRounded.glb wallDoorwayWide.glb
chairModernCushion.glb kitchenFridgeSmall.glb rugSquare.glb wallHalf.glb
chairModernFrameCushion.glb kitchenMicrowave.glb shower.glb wallWindow.glb
chairRounded.glb kitchenSink.glb showerRound.glb wallWindowSlide.glb
coatRack.glb kitchenStove.glb sideTable.glb washer.glb
coatRackStanding.glb kitchenStoveElectric.glb sideTableDrawers.glb washerDryerStacked.glb

assets/urban:
balcony-ladder-bottom.glb planks.glb truck-flat.glb wall-b-diagonal.glb
balcony-ladder-top.glb road-asphalt-center.glb truck-green-cargo.glb wall-b-door.glb
balcony-type-a.glb road-asphalt-corner-inner.glb truck-green.glb wall-b-flat-garage.glb
cliff-corner.glb road-asphalt-corner-outer.glb truck-grey-cargo.glb wall-b-flat-window.glb
cliff-side.glb road-asphalt-corner.glb truck-grey.glb wall-b-flat.glb
detail-awning-small.glb road-asphalt-damaged.glb wall-a-column-painted.glb wall-b-garage.glb
detail-awning-wide.glb road-asphalt-pavement.glb wall-a-column.glb wall-b-low.glb
detail-barrier-strong-damaged.glb road-asphalt-side.glb wall-a-corner-painted.glb wall-b-open.glb
detail-barrier-strong-type-a.glb road-asphalt-straight.glb wall-a-corner.glb wall-b-roof-detailed.glb
detail-barrier-strong-type-b.glb road-dirt-center.glb wall-a-detail-painted.glb wall-b-roof-slant-detailed.glb
detail-barrier-type-a.glb road-dirt-corner-inner.glb wall-a-detail.glb wall-b-roof-slant.glb
detail-barrier-type-b.glb road-dirt-corner-outer.glb wall-a-diagonal.glb wall-b-roof.glb
detail-beam.glb road-dirt-corner.glb wall-a-door.glb wall-b-window.glb
detail-bench.glb road-dirt-damaged.glb wall-a-flat-garage.glb wall-b.glb
detail-block.glb road-dirt-pavement.glb wall-a-flat-painted.glb wall-broken-type-a.glb
detail-bricks-type-a.glb road-dirt-side.glb wall-a-flat-window.glb wall-broken-type-b.glb
detail-bricks-type-b.glb road-dirt-straight.glb wall-a-flat.glb wall-c-flat-low.glb
detail-cables-type-a.glb road-dirt-tile.glb wall-a-garage.glb wall-c-flat.glb
detail-cables-type-b.glb roof-metal-poles.glb wall-a-low-painted.glb wall-fence.glb
detail-dumpster-closed.glb roof-metal-type-a.glb wall-a-low.glb wall-steps-type-a.glb
detail-dumpster-open.glb roof-metal-type-b.glb wall-a-open.glb wall-steps-type-b.glb
detail-light-double.glb scaffolding-floor.glb wall-a-painted-diagonal.glb wall-type-a.glb
detail-light-single.glb scaffolding-poles.glb wall-a-painted.glb wall-type-b.glb
detail-light-traffic.glb scaffolding-structure.glb wall-a-roof-detailed.glb window-small-type-a.glb
door-type-a.glb Textures wall-a-roof-slant-detailed.glb window-small-type-b.glb
door-type-b.glb tree-large.glb wall-a-roof-slant.glb window-wide-type-a.glb
grass-corner-inner.glb tree-park-large.glb wall-a-roof.glb window-wide-type-b.glb
grass-corner.glb tree-park-pine-large.glb wall-a-window.glb window-wide-type-c.glb
grass-hill.glb tree-pine-large.glb wall-a.glb window-wide-type-d.glb
grass.glb tree-pine-small.glb wall-b-column.glb
pallet-small.glb tree-shrub.glb wall-b-corner.glb
pallet.glb tree-small.glb wall-b-detail-painted.gl

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Container City Explorer</title>
    <style>
        body {
            margin: 0;
            background-color: #050510;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #info-container {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            max-width: 350px;
        }

        #info-container h2 {
            margin-top: 0;
        }

        #controls-info {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
        }

        .mode-indicator {
            font-style: italic;
            font-weight: bold;
            color: #4ade80;
            transition: all 0.3s ease-in-out;
        }

        #nav-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 8px;
        }

        #auto-mode-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="info-container">
            <h2 id="scene-title">Welcome!</h2>
            <p id="scene-description">Use the arrow keys to explore the container city.</p>
        </div>
        <div id="controls-info">
            <p>Current Mode: <span id="current-mode" class="mode-indicator">Noclip (Free) Mode</span></p>
            <p style="margin: 5px 0;">
                <b>Tab</b>: Toggle camera mode.
            </p>
            <b>Noclip Controls:</b>
            <p style="margin: 5px 0;">
                <b>WASD / ZQSD</b> : Move.<br>
                <b>R / F</b> : Move Up / Down.<br>
                <b>Mouse Drag</b> : Look around.<br>
                <b>Shift</b>: Increase speed.
            </p>
            <hr style="border-color: rgba(255,255,255,0.2);">
            <b>Snap Controls:</b>
            <p style="margin: 5px 0;">
                <b>&uarr; / &darr; / &larr; / &rarr;</b> : Move between containers.
            </p>
        </div>
    </div>

    <div id="nav-controls">
        <label id="auto-mode-label">
            <input type="checkbox" id="auto-mode-checkbox">
            Auto Mode
        </label>
        <button id="next-btn">Next</button>
    </div>

    <canvas id="c"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { gsap } from 'gsap';

        // --- SCENE SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const lookAtTarget = new THREE.Vector3(0, 2, -5); // Target for snap mode
        camera.position.set(0, 2, 10);
        camera.lookAt(lookAtTarget);

        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 15);
        scene.add(directionalLight);

        // --- CORE VARIABLES ---
        const containerSize = new THREE.Vector3(8, 4, 10);
        const wallThickness = 0.2;
        const humanHeight = 1.7;
        let currentNodeIndex = 0;
        let isAnimating = false;
        let isAutoMode = false;
        const loader = new GLTFLoader();

        // --- UI ELEMENTS ---
        const nextBtn = document.getElementById('next-btn');
        const autoModeCheckbox = document.getElementById('auto-mode-checkbox');
        const titleEl = document.getElementById('scene-title');
        const descEl = document.getElementById('scene-description');
        const modeIndicator = document.getElementById('current-mode');

        // --- CAMERA CONTROLS (Noclip) ---
        let isNoclipMode = true;
        let noclipKeys = {};
        let isShiftPressed = false;
        let mouseDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        const rotationSpeed = 0.002;
        let cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
        const noclipMoveSpeed = 0.1;
        const noclipMaxMoveSpeed = 0.5;

        // --- CITY LAYOUT DEFINITION ---
        const cityLayout = [
            { id: 0, pos: new THREE.Vector3(0, 0, 0), theme: createNoodleShop, title: "Noodle Shop", desc: "A cozy noodle shop. The steam warms the cold metal walls.", connections: { north: 1 } },
            { id: 1, pos: new THREE.Vector3(0, 0, -12), theme: createLivingQuarters, title: "Living Quarters", desc: "A cramped but functional living space.", connections: { south: 0, up: 2 } },
            { id: 2, pos: new THREE.Vector3(0, 5, -12), theme: createArcade, title: "Mini Arcade", desc: "A noisy, flashing escape from the quiet hum of the city.", connections: { down: 1, west: 3, east: 4 } },
            { id: 3, pos: new THREE.Vector3(-10, 5, -12), theme: createCafe, title: "Container Cafe", desc: "The aroma of coffee lingers in the air. A place to relax and recharge.", connections: { east: 2 } },
            { id: 4, pos: new THREE.Vector3(10, 5, -12), theme: createHydroponics, title: "Hydroponics Bay", desc: "The source of fresh greens, glowing under purple lights.", connections: { west: 2, north: 5 } },
            { id: 5, pos: new THREE.Vector3(10, 5, -24), theme: createStorage, title: "Storage Room", desc: "A disorganized pile of old stuff and forgotten crates.", connections: { south: 4, up: 6 } },
            { id: 6, pos: new THREE.Vector3(10, 10, -24), theme: createLookout, title: "Lookout Point", desc: "A vantage point overlooking the foggy, sprawling container city below.", connections: { down: 5 } },
        ];

        // --- ASSET LOADING HELPER ---
        function loadAsset(group, path, pos, scale, rot) {
            loader.load(
                path,
                (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(scale.x, scale.y, scale.z);
                    model.position.set(pos.x, pos.y, pos.z);
                    model.rotation.set(rot.x, rot.y, rot.z);
                    group.add(model);
                },
                undefined,
                (error) => console.error(`Failed to load model at ${path}`, error)
            );
        }

        // --- CONTAINER CREATION LOGIC ---
        function createContainer(node) {
            const group = new THREE.Group();
            group.position.copy(node.pos);

            const containerMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5 });

            const doorSize = { width: 2, height: 3 };

            const createWall = (size, position, rotation, connection) => {
                if (connection !== undefined && connection !== null) {
                    const wallGroup = new THREE.Group();
                    const wallW = size.x > size.z ? size.x : size.z;
                    const sideWidth = (wallW - doorSize.width) / 2;
                    const leftGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const leftMesh = new THREE.Mesh(leftGeo, containerMat);
                    leftMesh.position.x = -(doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(leftMesh);
                    const rightGeo = new THREE.BoxGeometry(sideWidth, size.y, wallThickness);
                    const rightMesh = new THREE.Mesh(rightGeo, containerMat);
                    rightMesh.position.x = (doorSize.width / 2 + sideWidth / 2);
                    wallGroup.add(rightMesh);
                    const topHeight = size.y - doorSize.height;
                    if (topHeight > 0) {
                        const topGeo = new THREE.BoxGeometry(doorSize.width, topHeight, wallThickness);
                        const topMesh = new THREE.Mesh(topGeo, containerMat);
                        topMesh.position.y = doorSize.height / 2 + topHeight / 2;
                        wallGroup.add(topMesh);
                    }
                    wallGroup.position.copy(position);
                    wallGroup.rotation.y = rotation;
                    return wallGroup;
                } else {
                    const wallGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const wallMesh = new THREE.Mesh(wallGeo, containerMat);
                    wallMesh.position.copy(position);
                    wallMesh.rotation.y = rotation;
                    return wallMesh;
                }
            };

            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, containerSize.z / 2), 0, node.connections.north));
            group.add(createWall(new THREE.Vector3(containerSize.x, containerSize.y, wallThickness), new THREE.Vector3(0, containerSize.y / 2, -containerSize.z / 2), 0, node.connections.south));
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.east));
            group.add(createWall(new THREE.Vector3(containerSize.z, containerSize.y, wallThickness), new THREE.Vector3(-containerSize.x / 2, containerSize.y / 2, 0), Math.PI / 2, node.connections.west));

            const floorGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const floor = new THREE.Mesh(floorGeo, containerMat);
            floor.position.y = 0;
            group.add(floor);

            const ceilingGeo = new THREE.BoxGeometry(containerSize.x, wallThickness, containerSize.z);
            const ceiling = new THREE.Mesh(ceilingGeo, containerMat);
            ceiling.position.y = containerSize.y;
            group.add(ceiling);

            // Add a default dim light to every container to avoid total darkness
            const defaultLight = new THREE.PointLight(0x333344, 5, 10);
            defaultLight.position.set(0, containerSize.y - 1, 0);
            group.add(defaultLight);

            if (node.theme) {
                const themedContent = node.theme(containerSize.x, containerSize.y, containerSize.z);
                group.add(themedContent);
            }

            scene.add(group);
        }

        // --- THEME FUNCTIONS (Populate containers) ---
        function createNoodleShop(w, h, d) {
            const group = new THREE.Group();
            const counterGeo = new THREE.BoxGeometry(w * 0.8, 1.2, 1);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter);

            loadAsset(group, 'assets/furnitures/stoolBar.glb', new THREE.Vector3(-1.5, 0, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/stoolBar.glb', new THREE.Vector3(1.5, 0, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            loadAsset(group, 'assets/food/bowl-broth.glb', new THREE.Vector3(-1.5, 1.2, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/chopstick.glb', new THREE.Vector3(-1.5, 1.2, 0.8), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, Math.PI, Math.PI / 2));
            loadAsset(group, 'assets/food/bowl-broth.glb', new THREE.Vector3(1.5, 1.2, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/chopstick.glb', new THREE.Vector3(1.5, 1.2, 0.8), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, Math.PI, Math.PI / 2));

            const light = new THREE.PointLight(0xffa500, 50, 8);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }

        function createLivingQuarters(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/cyberpunk/sofa_couch.glb', new THREE.Vector3(-w / 2 + 2, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/tableCoffee.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/televisionModern.glb', new THREE.Vector3(w / 2 - 1, 0.8, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/books.glb', new THREE.Vector3(w / 2 - 1, 1.4, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/furnitures/pottedPlant.glb', new THREE.Vector3(-w / 2 + 1, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));


            const light = new THREE.PointLight(0xeeeeff, 25, 12);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createCafe(w, h, d) {
            const group = new THREE.Group();
            loadAsset(group, 'assets/furnitures/tableRound.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/chair.glb', new THREE.Vector3(0, 0, -2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/chair.glb', new THREE.Vector3(0, 0, 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/food/cup-coffee.glb', new THREE.Vector3(0, 0.7, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/food/donut-chocolate.glb', new THREE.Vector3(0, 0.7, 0.5), new THREE.Vector3(1, 1, 1), new THREE.Vector3(Math.PI / 2, 0, 0));

            const counterGeo = new THREE.BoxGeometry(w * 0.8, 1.2, 1.5);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0x964B00 });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 0.6, -d / 2 + 1);
            group.add(counter);

            loadAsset(group, 'assets/food/cup-coffee.glb', new THREE.Vector3(0, 1.2, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            const light = new THREE.PointLight(0xffddaa, 30, 10);
            light.position.set(0, h - 1, 0);
            group.add(light);

            return group;
        }

        function createArcade(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/arcade/pinball.glb', new THREE.Vector3(-w / 4, 0, -d / 2 + 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/arcade/arcade-machine.glb', new THREE.Vector3(w / 4, 0, -d / 2 + 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI, 0));
            loadAsset(group, 'assets/arcade/claw-machine.glb', new THREE.Vector3(w / 2 - 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/arcade/prizes.glb', new THREE.Vector3(w / 2 - 1, 0.8, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));

            const light = new THREE.PointLight(0x00ffff, 40, 10);
            light.position.set(0, h / 2, 0);
            group.add(light);
            return group;
        }

        function createHydroponics(w, h, d) {
            const group = new THREE.Group();

            for (let i = 0; i < 4; i++) {
                loadAsset(group, 'assets/furnitures/pottedPlant.glb', new THREE.Vector3(0, 0, -d / 2 + 1 + i * 2), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            }

            const light = new THREE.PointLight(0xff00ff, 80, 12);
            light.position.set(0, h - 0.5, 0);
            group.add(light);
            return group;
        }

        function createStorage(w, h, d) {
            const group = new THREE.Group();

            loadAsset(group, 'assets/urban/pallet.glb', new THREE.Vector3(-1.5, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/pallet.glb', new THREE.Vector3(1.5, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/cardboardBoxOpen.glb', new THREE.Vector3(-1.5, 0.1, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/furnitures/cardboardBoxClosed.glb', new THREE.Vector3(1.5, 0.1, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/trashcan.glb', new THREE.Vector3(-w / 2 + 1, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));

            const light = new THREE.PointLight(0xaaaaaa, 20, 15);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }

        function createLookout(w, h, d) {
            const group = new THREE.Group();
            loadAsset(group, 'assets/urban/detail-barrier-strong-type-a.glb', new THREE.Vector3(0, 0, -d / 2 + 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0));
            loadAsset(group, 'assets/urban/detail-bench.glb', new THREE.Vector3(w / 2 - 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -Math.PI / 2, 0));
            loadAsset(group, 'assets/urban/detail-light-single.glb', new THREE.Vector3(-w / 2 + 1, 0, 0), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, Math.PI / 2, 0));

            const light = new THREE.PointLight(0x6677aa, 20, 15);
            light.position.set(0, h - 1, 0);
            group.add(light);
            return group;
        }


        // --- NAVIGATION & ANIMATION (Snap Mode) ---
        function navigateToNode(nodeIndex) {
            if (isAnimating || nodeIndex === null || nodeIndex === undefined) return;
            isAnimating = true;
            currentNodeIndex = nodeIndex;

            const targetNode = cityLayout.find(n => n.id === nodeIndex);
            if (!targetNode) {
                isAnimating = false;
                return;
            }

            titleEl.innerText = targetNode.title;
            descEl.innerText = targetNode.desc;
            nextBtn.disabled = true;

            const cameraPos = new THREE.Vector3(
                targetNode.pos.x,
                targetNode.pos.y + humanHeight,
                targetNode.pos.z + containerSize.z * 0.4
            );

            let lookAtPos;
            const primaryDirection = targetNode.connections.north ?? targetNode.connections.east ?? targetNode.connections.south ?? targetNode.connections.west ?? null;
            if (primaryDirection !== null) {
                const nextNode = cityLayout.find(n => n.id === primaryDirection);
                if (nextNode) {
                    lookAtPos = new THREE.Vector3(nextNode.pos.x, nextNode.pos.y + humanHeight, nextNode.pos.z);
                }
            }

            if (!lookAtPos) {
                lookAtPos = new THREE.Vector3(targetNode.pos.x, targetNode.pos.y + humanHeight, targetNode.pos.z - 5);
            }
            
            gsap.to(camera.position, { ...cameraPos, duration: 1.5, ease: 'power2.inOut' });
            gsap.to(lookAtTarget, {
                ...lookAtPos,
                duration: 1.5,
                ease: 'power2.inOut',
                onComplete: () => {
                    isAnimating = false;
                    if (isAutoMode) nextBtn.disabled = false;
                }
            });
        }

        // --- EVENT LISTENERS ---
        function handleNoclipMovement() {
            const speed = isShiftPressed ? noclipMaxMoveSpeed : noclipMoveSpeed;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

            if (noclipKeys['w'] || noclipKeys['z']) {
                camera.position.add(forward.multiplyScalar(speed));
            }
            if (noclipKeys['s']) {
                camera.position.sub(forward.multiplyScalar(speed));
            }
            if (noclipKeys['a'] || noclipKeys['q']) {
                camera.position.sub(right.multiplyScalar(speed));
            }
            if (noclipKeys['d']) {
                camera.position.add(right.multiplyScalar(speed));
            }
            if (noclipKeys['r']) {
                camera.position.y += speed;
            }
            if (noclipKeys['f']) {
                camera.position.y -= speed;
            }
        }
        
        function handleSnapMovement(event) {
            if (isAnimating || isAutoMode) return;

            const currentNode = cityLayout.find(n => n.id === currentNodeIndex);
            let nextNodeId = null;

            switch (event.key) { // Check for the key's name, which includes "Arrow"
                case 'ArrowUp':
                    nextNodeId = currentNode.connections.north;
                    break;
                case 'ArrowDown':
                    nextNodeId = currentNode.connections.south;
                    break;
                case 'ArrowLeft':
                    nextNodeId = currentNode.connections.west;
                    break;
                case 'ArrowRight':
                    nextNodeId = currentNode.connections.east;
                    break;
            }

            if (nextNodeId !== undefined && nextNodeId !== null) {
                navigateToNode(nextNodeId);
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                isNoclipMode = !isNoclipMode;
                modeIndicator.textContent = isNoclipMode ? 'Noclip (Free) Mode' : 'Snap (Container) Mode';
                
                if (!isNoclipMode) {
                    const currentNode = cityLayout.find(n => n.id === currentNodeIndex);
                    if (currentNode) {
                         const cameraPos = new THREE.Vector3(
                            currentNode.pos.x,
                            currentNode.pos.y + humanHeight,
                            currentNode.pos.z + containerSize.z * 0.4
                        );
                        gsap.to(camera.position, { ...cameraPos, duration: 0.5, ease: 'power2.inOut' });
                        canvas.style.cursor = 'default';
                    }
                } else {
                    canvas.style.cursor = 'grab';
                }
            }

            if (isNoclipMode) {
                noclipKeys[e.key.toLowerCase()] = true;
                if (e.key === 'Shift') {
                    isShiftPressed = true;
                }
            } else {
                handleSnapMovement(e);
            }
        });

        window.addEventListener('keyup', (e) => {
            noclipKeys[e.key.toLowerCase()] = false;
            if (e.key === 'Shift') {
                isShiftPressed = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (isNoclipMode) {
                mouseDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDragging = false;
            if(isNoclipMode) {
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDragging && isNoclipMode) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                cameraRotation.y -= deltaX * rotationSpeed;
                cameraRotation.x -= deltaY * rotationSpeed;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                camera.quaternion.setFromEuler(cameraRotation);
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        nextBtn.addEventListener('click', () => {
            if (isAutoMode && !isAnimating) {
                let nextIndex = (currentNodeIndex + 1) % cityLayout.length;
                navigateToNode(nextIndex);
            }
        });

        autoModeCheckbox.addEventListener('change', (e) => {
            isAutoMode = e.target.checked;
            nextBtn.disabled = !isAutoMode;
            nextBtn.style.opacity = isAutoMode ? '1' : '0.5';
        });

        // --- INITIALIZATION ---
        function buildWorld() {
            cityLayout.forEach(node => createContainer(node));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);

            if (isNoclipMode) {
                handleNoclipMovement();
            } else {
                camera.lookAt(lookAtTarget);
            }

            renderer.render(scene, camera);
        }

        buildWorld();
        navigateToNode(0);
        autoModeCheckbox.checked = false;
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.5';
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvas.style.cursor = 'grab';
        
        setTimeout(() => {
            animate();
        }, 100);
    </script>
</body>

</html>
